{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Business Objectives","text":""},{"location":"#context","title":"Context","text":"<p>Assume you have 2 services:</p> <ul> <li>Service 1 is responsible for creating a table A</li> <li>Service 2 requires using data from that same table A</li> </ul> <p>You can modify Service 1 to change the format/schema/content of table A, like:</p> <ul> <li>Remove/Add a column</li> <li>Change the data type of a columns<ul> <li>Change from Integer to String</li> </ul> </li> <li>Change the semantic meaning of a column</li> <li>Change the constraints on the values of a column<ul> <li>Column uniqueness</li> <li>Column cannot be empty</li> <li>Column allowed values</li> </ul> </li> </ul> <p>On the other hand, the \"requirements\" from Service 2 can be more or less strict</p> <ul> <li>It only needs a subset of columns from table A</li> <li>It requires a subset of the Allowed Values for a column<ul> <li>E.g. Service 2 only cares about properties in the COUNTRY = UK, so if COUNTRY = FRANCE is removed from table A, it doesn't care.</li> </ul> </li> </ul> <p>Given the possible scenarios above, a challenge that emerges is with knowing, at time of the MR/PR (merge/pull request), if the incoming changes to one of the Services will cause Service 2's table A expectations to not be met.</p> <ul> <li>Service 1 will remove a column from table A, when that same column is required by Service 2.</li> <li>Service 2 adds a new expectation of a Column X that is not being produced by Service 1</li> </ul> <p>Additionally, even if \"on paper\" the two services agree regarding table A, it can happen that during execution, one of the services encounters data that do not match the expectations.</p> <ul> <li>Service 1 says column X cannot be empty, Service 2 expects column X to not be empty, but column X has empty values when retrieved by Service 2. Service 1 may have emitted a Warning, but whether it stops Column X from being propagated is a whole different matter.</li> </ul>"},{"location":"#goal","title":"Goal","text":"<p>The goal of Data Contracts is to allow different Services in a System to share their expectations and requirements on Tables, allowing those expectations and requirements to be compared and the system to bring awareness of potentially incompatible expectations from their Services.</p> <p>One key aspect of achieving this is making sure there is a standardised way of declaring the expectations and requirements that a Service has on a Table.</p>"},{"location":"#what-is-a-data-contract","title":"What is a Data Contract","text":"<p>A Data Contract is an artifact containing a collection of metadata about a Table. Such table can be a database table, or a \"file based\" table, like CSV, Excel or Parquet.</p> <p>A Data Contract can refer to either an Incoming Table or an Outcoming Table. If the Data Contract refers to an Outcoming Table it can be called a Producer Data Contract. On the other hand, if the Data Contract refers to an Incoming Talbe it can be called a Consumer Data Contract.</p> <p>The minimum metadata a Data Contract should contain is a list of columns in a table, alongside their description, data types and basic constraints. It could also contain more information, but those would most likely vary across the different implementations of Data Contracts.</p> <p>For a system, there should be a centralised \"data contracts catalog\", that keeps track of all \"producers\" and \"consumers\" of Data Contracts and can perform \"compatibility checks\" between them.</p> <p>In a well designed system, a table should only be \"produced\" by a single Service, whereas many Services may \"consume\" it. This leads to the constraint that \"no 2 distinct Producer Data Contracts may refer to the same Table\".</p>"},{"location":"#data-contract-implementation","title":"Data Contract Implementation","text":"<p>Data Contracts can be represented in many ways. One way that I particularly like is \"metadata only parquet files\" where the Metadata comes from an Arrow Schema. The reasons I like this are the following:</p> <ul> <li> <p>Arrow is becoming the standard way of manipulating data in a Service, and Arrow is itself a \"universal standard\" that has implementations in all mainstream programming languages like Python, Java, Rust, Javascript, Go, R, etc.</p> <ul> <li>This means that the Data Contracts are agnostic of what programming language was used to create it.</li> </ul> </li> <li> <p>Arrow Schemas contain not only the list of columns and their types, but also allow the adition of Custom Metadata to both individual Columns and to the whole table.</p> <ul> <li>This Custom Metadata can contain virtually anything. In particular, it can contain Column descriptions, the specification of column tests, etc, and within a System the distinct Services should agree on how to use the Custom Metadata</li> </ul> </li> <li> <p>You can very easily write an Arrow Schema in several languages and save it to a Metadata Only Parquet File</p> </li> </ul>"},{"location":"Design/","title":"Design","text":"<ul> <li>Create Field and Table metadata with class adc.Metadata()</li> <li>Create Arrow schema with Field Names and Types, and metadata value coming from class Metadata</li> <li> <p>Create DataContract giving it a name, a schema and a direction.</p> </li> <li> <p>As part of the CICD pipeline, call <code>adc check</code>.</p> <ul> <li>This will crawl the directory found in pyproject.toml file or env var X to build the ServiceCatalog object. The ServiceCatalog contains a mapping of all Contract Names found and their corresponding DataContract object</li> <li>Will call method <code>generate_files</code> to create all Metadata Only Parquet Files for the Service</li> <li>Will connect to the CatalogRepository and fetch all relevant existing DataContracts from other services</li> <li>Will run the SchemaCompatibility check between all relevant DataContract and yield a compatibility report for each check</li> </ul> </li> <li> <p>If <code>adc check</code> doesn't raise any failures, then call <code>adc upload</code></p> <ul> <li>Will call method <code>upload_catalog_files</code> of CatalogRepository to replace the existing Service Data Contracts with the new ones coming from the PR/MR.</li> </ul> </li> </ul>"},{"location":"Roadmap/","title":"Roadmap","text":"<ul> <li>Improve SchemaCompatibility class to handle nested fields</li> <li>Improve Metadata Class to allow custom SQL tests</li> </ul>"},{"location":"getting_started/","title":"Getting Started","text":"<p>On your python project, ha</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>adc<ul> <li>catalog<ul> <li>catalog_repository</li> <li>catalog_repository_backend_local</li> <li>catalog_repository_entry</li> </ul> </li> <li>data_contract</li> <li>data_contract_compatibility</li> <li>metadata<ul> <li>direction</li> <li>field_test_metadata</li> <li>table_metadata</li> </ul> </li> <li>schema_compatibility</li> <li>service_catalog</li> </ul> </li> </ul>"},{"location":"reference/adc/","title":"Code Reference","text":""},{"location":"reference/adc/data_contract/","title":"Data contract","text":""},{"location":"reference/adc/data_contract/#adc.data_contract.DataContract","title":"<code>DataContract</code>","text":"<p>Examples:</p> <pre><code>&gt;&gt;&gt; my_contract_1 = DataContract(pa.schema([\n...         pa.field(\"n_legs\", pa.int64(),metadata=FieldMetadata().add_test_not_null().done()),\n...     ],\n...     metadata=TableMetadata(name=\"FOO\",direction='CONSUMER').done()\n... ))\n&gt;&gt;&gt; my_contract_1\nDataContract(FOO,CONSUMER,)\n</code></pre> <pre><code>&gt;&gt;&gt; my_contract_1.field('n_legs')\npyarrow.Field&lt;n_legs: int64&gt;\n</code></pre> <pre><code>&gt;&gt;&gt; my_contract_1.field_metadata('n_legs')\nFieldMetadata(tests=FieldTestMetadata(not_null=True, allowed_values=None))\n</code></pre> <pre><code>&gt;&gt;&gt; my_contract_1.to_file(Path(\"DEMO_DATA_CONTRACTS\"))\nPosixPath('DEMO_DATA_CONTRACTS/CONSUMER/FOO.parquet')\n</code></pre> <pre><code>&gt;&gt;&gt; my_contract_2 = my_contract_1.from_file(Path('DEMO_DATA_CONTRACTS/CONSUMER/FOO.parquet'))\n&gt;&gt;&gt; my_contract_2\nDataContract(FOO,CONSUMER,)\n</code></pre> <pre><code>&gt;&gt;&gt; shutil.rmtree(Path(\"DEMO_DATA_CONTRACTS\"))\n</code></pre> <pre><code>&gt;&gt;&gt; my_contract_1.service = \"my_service\"\n&gt;&gt;&gt; my_contract_1.service\n'my_service'\n</code></pre> Source code in <code>src/adc/data_contract.py</code> <pre><code>class DataContract:\n\"\"\"\n\n    Examples:\n        &gt;&gt;&gt; my_contract_1 = DataContract(pa.schema([\n        ...         pa.field(\"n_legs\", pa.int64(),metadata=FieldMetadata().add_test_not_null().done()),\n        ...     ],\n        ...     metadata=TableMetadata(name=\"FOO\",direction='CONSUMER').done()\n        ... ))\n        &gt;&gt;&gt; my_contract_1\n        DataContract(FOO,CONSUMER,)\n\n        &gt;&gt;&gt; my_contract_1.field('n_legs')\n        pyarrow.Field&lt;n_legs: int64&gt;\n\n        &gt;&gt;&gt; my_contract_1.field_metadata('n_legs')\n        FieldMetadata(tests=FieldTestMetadata(not_null=True, allowed_values=None))\n\n        &gt;&gt;&gt; my_contract_1.to_file(Path(\"DEMO_DATA_CONTRACTS\"))\n        PosixPath('DEMO_DATA_CONTRACTS/CONSUMER/FOO.parquet')\n\n        &gt;&gt;&gt; my_contract_2 = my_contract_1.from_file(Path('DEMO_DATA_CONTRACTS/CONSUMER/FOO.parquet'))\n        &gt;&gt;&gt; my_contract_2\n        DataContract(FOO,CONSUMER,)\n\n        &gt;&gt;&gt; shutil.rmtree(Path(\"DEMO_DATA_CONTRACTS\"))\n\n        &gt;&gt;&gt; my_contract_1.service = \"my_service\"\n        &gt;&gt;&gt; my_contract_1.service\n        'my_service'\n\n\n    \"\"\"\n\n    def __init__(\n        self,\n        schema: pa.Schema,\n    ):\n        self.schema = schema\n\n    @property\n    def metadata(self) -&gt; TableMetadata:\n        table_metadata = TableMetadata.from_encoded(self.schema.metadata)\n        return table_metadata\n\n    @property\n    def name(self) -&gt; str:\n        return self.metadata.name\n\n    @property\n    def direction(self) -&gt; Direction:\n        return self.metadata.direction\n\n    @property\n    def service(self) -&gt; Optional[str]:\n        return self.metadata.service\n\n    @service.setter\n    def service(self, value: str) -&gt; str:\n        new_metadata = self.metadata\n        new_metadata.service = value\n        new_metadata_encoded = new_metadata.done()\n        new_schema = self.schema.with_metadata(new_metadata_encoded)\n        self.schema = new_schema\n        return value\n\n    def __str__(self):\n        return f\"DataContract({self.name},{self.direction.name},{self.service or ''})\"\n\n    def __repr__(self):\n        return str(self)\n\n    def field(self, name):\n        return self.schema.field(name)\n\n    def field_metadata(self, name):\n        field_metadata = FieldMetadata.from_encoded(self.schema.field(name).metadata)\n        return field_metadata\n\n    # @staticmethod\n    # def schema_test(tbl, column_name, column_index, test_name, test_value):\n    #     if test_name == \"allowed_values\":\n    #         dictionary_encoded_column = tbl.column(column_name).dictionary_encode()\n    #         tbl = tbl.set_column(column_index, column_name, dictionary_encoded_column)\n    #         allowed_values = pa.array(test_value)\n    #         existing_values = dictionary_encoded_column.chunk(0).dictionary\n    #         test_result = all(ev in allowed_values for ev in existing_values)\n    #         return tbl, {\n    #             test_name: {\n    #                 \"allowed_values\": allowed_values.to_pylist(),\n    #                 \"existing_values\": existing_values.to_pylist(),\n    #                 \"result\": test_result,\n    #             }\n    #         }\n\n    # def validate_table(self, incoming_tbl):\n    #     my_schema = self.schema\n\n    #     casted_tbl = incoming_tbl.cast(my_schema)\n\n    #     table_test_results = dict()\n\n    #     for field in my_schema:\n    #         field_metadata = field.metadata\n    #         if not field_metadata:\n    #             continue\n    #         if b\"tests\" not in field_metadata:\n    #             continue\n\n    #         # // Deserialize the category information\n    #         column_tests = json.loads(field_metadata[b\"tests\"])\n    #         column_name = field.name\n    #         column_index = my_schema.get_field_index(column_name)\n\n    #         column_test_results = dict()\n    #         for test_name, test_value in column_tests.items():\n    #             casted_tbl, test_result = DataContract.schema_test(\n    #                 casted_tbl, column_name, column_index, test_name, test_value\n    #             )\n    #             column_test_results = column_test_results | test_result\n\n    #         table_test_results = table_test_results | {column_name: column_test_results}\n\n    #     return casted_tbl, table_test_results\n\n    def to_file(self, base_path: Path) -&gt; Path:\n        filepath = (base_path / self.direction.name / self.name).with_suffix(\".parquet\")\n        filepath.parent.mkdir(exist_ok=True, parents=True)\n        pq.write_metadata(self.schema, filepath)\n        return filepath\n\n    @classmethod\n    def from_file(cls, filepath: Path):\n        file_metadata = pq.read_metadata(filepath)\n        arrow_schema = file_metadata.schema.to_arrow_schema()\n        return cls(arrow_schema)\n</code></pre>"},{"location":"reference/adc/data_contract_compatibility/","title":"Data contract compatibility","text":""},{"location":"reference/adc/schema_compatibility/","title":"Schema compatibility","text":""},{"location":"reference/adc/service_catalog/","title":"Service catalog","text":""},{"location":"reference/adc/service_catalog/#adc.service_catalog.ServiceCatalog","title":"<code>ServiceCatalog</code>","text":"<p>Examples:</p> <pre><code>&gt;&gt;&gt; service_1_catalog = ServiceCatalog(\"service_1\")\n&gt;&gt;&gt; service_1_catalog\nServiceCatalog('service_1')\n</code></pre> <pre><code>&gt;&gt;&gt; my_contract_1 = DataContract(pa.schema([\n...         pa.field(\"n_legs\", pa.int64(),metadata=FieldMetadata().add_test_not_null().done()),\n...     ],\n...     metadata=TableMetadata(name=\"FOO\",direction='CONSUMER').done()\n... ))\n&gt;&gt;&gt; service_1_catalog.add_contract(my_contract_1)\n&gt;&gt;&gt; service_1_catalog.contracts\n{'FOO': DataContract(FOO,CONSUMER,service_1)}\n</code></pre> <pre><code>&gt;&gt;&gt; my_contract_2 = DataContract(pa.schema([\n...         pa.field(\"n_legs\", pa.int64(),metadata=FieldMetadata().add_test_not_null().done()),\n...     ],\n...     metadata=TableMetadata(name=\"BAR\",direction='CONSUMER',service='service_BLA').done()\n... ))\n&gt;&gt;&gt; service_1_catalog.add_contract(my_contract_2)\nTraceback (most recent call last):\nadc.service_catalog.ContractServiceDoesntMatchServiceCatalogName: Contract named BAR with 'service' = 'service_BLA' is trying to be added to service catalog named 'service_1'.\n</code></pre> Source code in <code>src/adc/service_catalog.py</code> <pre><code>class ServiceCatalog:\n\"\"\"\n\n    Examples:\n        &gt;&gt;&gt; service_1_catalog = ServiceCatalog(\"service_1\")\n        &gt;&gt;&gt; service_1_catalog\n        ServiceCatalog('service_1')\n\n        &gt;&gt;&gt; my_contract_1 = DataContract(pa.schema([\n        ...         pa.field(\"n_legs\", pa.int64(),metadata=FieldMetadata().add_test_not_null().done()),\n        ...     ],\n        ...     metadata=TableMetadata(name=\"FOO\",direction='CONSUMER').done()\n        ... ))\n        &gt;&gt;&gt; service_1_catalog.add_contract(my_contract_1)\n        &gt;&gt;&gt; service_1_catalog.contracts\n        {'FOO': DataContract(FOO,CONSUMER,service_1)}\n\n        &gt;&gt;&gt; my_contract_2 = DataContract(pa.schema([\n        ...         pa.field(\"n_legs\", pa.int64(),metadata=FieldMetadata().add_test_not_null().done()),\n        ...     ],\n        ...     metadata=TableMetadata(name=\"BAR\",direction='CONSUMER',service='service_BLA').done()\n        ... ))\n        &gt;&gt;&gt; service_1_catalog.add_contract(my_contract_2)\n        Traceback (most recent call last):\n        adc.service_catalog.ContractServiceDoesntMatchServiceCatalogName: Contract named BAR with 'service' = 'service_BLA' is trying to be added to service catalog named 'service_1'.\n\n\n\n    \"\"\"\n\n    def __init__(self, name: str):\n        self.name = name\n        self.contracts: Dict[str, DataContract] = dict()\n\n    def __repr__(self):\n        return f\"ServiceCatalog('{self.name}')\"\n\n    def add_contract(self, contract: DataContract) -&gt; None:\n        contract_name = contract.name\n\n        if contract_name in self.contracts:\n            raise ContractAlreadyRegistered(contract_name)\n\n        if contract.service and contract.service != self.name:\n            raise ContractServiceDoesntMatchServiceCatalogName(\n                contract_name, contract.service, self.name\n            )\n        else:\n            contract.service = self.name\n\n        self.contracts.update({contract_name: contract})\n\n    def load(self, path: Path):\n        for python_file in path.glob(\"**/*.py\"):\n            module_path = str(python_file.parent / python_file.stem).replace(\"/\", \".\")\n            module = importlib.import_module(module_path)\n\n            data_contracts_in_module = [\n                module_object\n                for module_object in module.__dict__.values()\n                if isinstance(module_object, DataContract)\n            ]\n\n            for data_contract in data_contracts_in_module:\n                self.add_contract(data_contract)\n\n    def get(self, name) -&gt; Optional[DataContract]:\n        if contract := self.contracts.get(name):\n            return contract\n        raise ContractNotFound(name)\n\n    def generate_files(self, base_path) -&gt; List[Path]:\n        all_files = [\n            contract.to_file(base_path) for _, contract in self.contracts.items()\n        ]\n        return all_files\n\n    def get_consumers(self) -&gt; Dict[str, DataContract]:\n        result = {\n            name: contract\n            for name, contract in self.contracts.items()\n            if contract.direction == Direction.CONSUMER\n        }\n        return result\n\n    def get_producers(self) -&gt; Dict[str, DataContract]:\n        result = {\n            name: contract\n            for name, contract in self.contracts.items()\n            if contract.direction == Direction.PRODUCER\n        }\n        return result\n</code></pre>"},{"location":"reference/adc/catalog/","title":"Catalog","text":""},{"location":"reference/adc/catalog/catalog_repository/","title":"Catalog repository","text":""},{"location":"reference/adc/catalog/catalog_repository_backend_local/","title":"Catalog repository backend local","text":""},{"location":"reference/adc/catalog/catalog_repository_entry/","title":"Catalog repository entry","text":""},{"location":"reference/adc/metadata/","title":"Metadata","text":""},{"location":"reference/adc/metadata/direction/","title":"Direction","text":""},{"location":"reference/adc/metadata/direction/#adc.metadata.direction.Direction","title":"<code>Direction</code>","text":"<p>         Bases: <code>str</code>, <code>Enum</code></p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; consumer = Direction['CONSUMER']\n&gt;&gt;&gt; consumer\nCONSUMER\n</code></pre> <pre><code>&gt;&gt;&gt; consumer.opposite()\nPRODUCER\n</code></pre> <pre><code>&gt;&gt;&gt; consumer.opposite().opposite() == consumer\nTrue\n</code></pre> Source code in <code>src/adc/metadata/direction.py</code> <pre><code>class Direction(str, Enum):\n\"\"\"\n    Examples:\n        &gt;&gt;&gt; consumer = Direction['CONSUMER']\n        &gt;&gt;&gt; consumer\n        CONSUMER\n\n        &gt;&gt;&gt; consumer.opposite()\n        PRODUCER\n\n        &gt;&gt;&gt; consumer.opposite().opposite() == consumer\n        True\n\n    \"\"\"\n\n    CONSUMER = \"CONSUMER\"\n    PRODUCER = \"PRODUCER\"\n\n    def opposite(self):\n        return Direction.PRODUCER if self == Direction.CONSUMER else Direction.CONSUMER\n\n    def __repr__(self):\n        return self.value\n</code></pre>"},{"location":"reference/adc/metadata/field_test_metadata/","title":"Field test metadata","text":""},{"location":"reference/adc/metadata/field_test_metadata/#adc.metadata.field_test_metadata.FieldMetadata","title":"<code>FieldMetadata</code>","text":"<p>Examples:</p> <pre><code>&gt;&gt;&gt; FieldTestMetadata(not_null=True)\nFieldTestMetadata(not_null=True, allowed_values=None)\n</code></pre> <pre><code>&gt;&gt;&gt; FieldMetadata(tests=FieldTestMetadata(not_null=True))\nFieldMetadata(tests=FieldTestMetadata(not_null=True, allowed_values=None))\n</code></pre> <pre><code>&gt;&gt;&gt; FieldMetadata().add_test_not_null()\nFieldMetadata(tests=FieldTestMetadata(not_null=True, allowed_values=None))\n</code></pre> Source code in <code>src/adc/metadata/field_test_metadata.py</code> <pre><code>@define\nclass FieldMetadata:\n\"\"\"\n\n    Examples:\n        &gt;&gt;&gt; FieldTestMetadata(not_null=True)\n        FieldTestMetadata(not_null=True, allowed_values=None)\n\n        &gt;&gt;&gt; FieldMetadata(tests=FieldTestMetadata(not_null=True))\n        FieldMetadata(tests=FieldTestMetadata(not_null=True, allowed_values=None))\n\n        &gt;&gt;&gt; FieldMetadata().add_test_not_null()\n        FieldMetadata(tests=FieldTestMetadata(not_null=True, allowed_values=None))\n\n    \"\"\"\n\n    tests: FieldTestMetadata = field(\n        default=FieldTestMetadata(), converter=FieldTestMetadata.from_dict\n    )\n\n    def done(self) -&gt; dict[bytes, bytes]:\n        return {\n            k.encode(\"utf8\"): json.dumps(v, default=str).encode(\"utf8\")\n            for k, v in attrs.asdict(self).items()\n        }\n\n    @classmethod\n    def from_encoded(cls, encoded_metadata: dict[bytes, bytes]) -&gt; Self:\n        raw_dict = {\n            k.decode(\"utf-8\"): json.loads(v.decode(\"utf-8\"))\n            for k, v in encoded_metadata.items()\n        }\n        return cls(**raw_dict)\n\n    def add_test_not_null(self) -&gt; Self:\n        self.tests.not_null = True\n        return self\n</code></pre>"},{"location":"reference/adc/metadata/table_metadata/","title":"Table metadata","text":""},{"location":"reference/adc/metadata/table_metadata/#adc.metadata.table_metadata.TableMetadata","title":"<code>TableMetadata</code>","text":"<p>Examples:</p> <pre><code>&gt;&gt;&gt; TableMetadata(name=\"FOO\", direction='CONSUMER')\nTableMetadata(name='FOO', direction=CONSUMER, service=None)\n</code></pre> <pre><code>&gt;&gt;&gt; TableMetadata(name=\"FOO\", direction='CONSUMER').direction\nCONSUMER\n</code></pre> Source code in <code>src/adc/metadata/table_metadata.py</code> <pre><code>@define\nclass TableMetadata:\n\"\"\"\n\n    Examples:\n        &gt;&gt;&gt; TableMetadata(name=\"FOO\", direction='CONSUMER')\n        TableMetadata(name='FOO', direction=CONSUMER, service=None)\n\n        &gt;&gt;&gt; TableMetadata(name=\"FOO\", direction='CONSUMER').direction\n        CONSUMER\n\n    \"\"\"\n\n    name: str\n    direction: Direction = field(converter=_direction_converter)\n    service: Optional[str] = None\n\n    def done(self) -&gt; dict[bytes, bytes]:\n        return {\n            k.encode(\"utf8\"): json.dumps(v, default=str).encode(\"utf8\")\n            for k, v in attrs.asdict(self).items()\n        }\n\n    @classmethod\n    def from_encoded(cls, encoded_metadata) -&gt; Self:\n        raw_dict = {\n            k.decode(\"utf-8\"): json.loads(v.decode(\"utf-8\"))\n            for k, v in encoded_metadata.items()\n        }\n        return cls(**raw_dict)\n</code></pre>"}]}